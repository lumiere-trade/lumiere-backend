"""
Base Trading Strategy Class.

This is the base class that all TSDL-generated strategies inherit from.
Plugin-specific features (like indicators) are added by plugin compilers.
"""

from abc import ABC, abstractmethod
from datetime import datetime
from typing import Any, Dict, Optional

from shared.strategy.exceptions import RiskLimitError
from shared.strategy.position import Position


class TradingStrategy(ABC):
    """Base class for trading strategies.

    All TSDL-generated strategies inherit from this class.
    Plugin-specific code is generated by plugin compilers.
    """

    def __init__(
        self,
        name: str,
        symbol: str,
        timeframe: str,
        config: Optional[Dict[str, Any]] = None,
    ):
        """Initialize trading strategy."""
        self.name = name
        self.symbol = symbol
        self.timeframe = timeframe
        self.config = config or {}

        # Risk management configuration
        self.max_position_size: Optional[float] = self.config.get("max_position_size")
        self.max_trades_per_day: Optional[int] = self.config.get("max_trades_per_day")
        self.max_daily_loss: Optional[float] = self.config.get("max_daily_loss")

        # Position sizing configuration
        self.position_sizing_method: str = self.config.get(
            "position_sizing_method", "fixed"
        )
        self.position_size: float = self.config.get("position_size", 0.0)
        self.position_percentage: float = self.config.get("position_percentage", 0.0)

        # Trade tracking
        self.trades_today: int = 0
        self.daily_pnl: float = 0.0
        self.last_reset_date: Optional[datetime] = None

        # State management for indicator history (for crosses detection, lookback)
        self._prev_indicators: Dict[str, Any] = {}

    @abstractmethod
    def check_entry_conditions(
        self,
        market_data: Dict[str, Any],
    ) -> bool:
        """Check if entry conditions are met.

        Args:
            market_data: Current market data (plugin-specific structure)

        Returns:
            True if entry conditions are met

        Note:
            Plugin compilers may add additional parameters (e.g., indicators)
        """

    @abstractmethod
    def check_exit_conditions(
        self,
        position: Position,
        market_data: Dict[str, Any],
    ) -> bool:
        """Check if exit conditions are met.

        Args:
            position: Current position
            market_data: Current market data (plugin-specific structure)

        Returns:
            True if exit conditions are met

        Note:
            Plugin compilers may add additional parameters (e.g., indicators)
        """

    def _update_previous_values(self, indicators: Dict[str, Any]) -> None:
        """Update previous indicator values for next iteration.

        This method should be called after check_entry_conditions() or
        check_exit_conditions() to store current values for next comparison.

        Args:
            indicators: Current indicator values to store
        """
        self._prev_indicators = indicators.copy()

    def _get_previous_value(self, indicator_name: str, default: Any = 0) -> Any:
        """Get previous value of an indicator.

        Args:
            indicator_name: Name of the indicator
            default: Default value if indicator not found in history

        Returns:
            Previous value of the indicator or default
        """
        return self._prev_indicators.get(indicator_name, default)

    def calculate_position_size(
        self,
        balance: float,
        price: float,
    ) -> float:
        """Calculate position size based on configuration.

        Args:
            balance: Available balance in quote currency
            price: Current price

        Returns:
            Position size in base currency

        Raises:
            RiskLimitError: If size exceeds max_position_size
        """
        if self.position_sizing_method == "fixed":
            size = self.position_size / price
        elif self.position_sizing_method == "percentage":
            size = (balance * self.position_percentage / 100) / price
        else:
            size = 0.0

        if self.max_position_size and size * price > self.max_position_size:
            raise RiskLimitError(
                "max_position_size", self.max_position_size, size * price
            )

        return size

    def can_trade(self) -> bool:
        """Check if trading is allowed based on risk limits.

        Returns:
            True if trading is allowed, False otherwise
        """
        now = datetime.now()

        # Reset daily counters at start of new day
        if self.last_reset_date is None or self.last_reset_date.date() != now.date():
            self.trades_today = 0
            self.daily_pnl = 0.0
            self.last_reset_date = now

        # Check max trades per day
        if self.max_trades_per_day and self.trades_today >= self.max_trades_per_day:
            return False

        # Check max daily loss
        if self.max_daily_loss and self.daily_pnl <= -abs(self.max_daily_loss):
            return False

        return True

    def record_trade(self, pnl: float) -> None:
        """Record a completed trade.

        Args:
            pnl: Trade profit/loss
        """
        self.trades_today += 1
        self.daily_pnl += pnl

    def __repr__(self) -> str:
        """String representation."""
        return (
            f"{self.__class__.__name__}("
            f"name='{self.name}', "
            f"symbol='{self.symbol}', "
            f"timeframe='{self.timeframe}')"
        )
